# SPDX-FileCopyrightText: Copyright (c) 2025 NVIDIA CORPORATION & AFFILIATES. All rights reserved.
# SPDX-License-Identifier: Apache-2.0

"""Retrieval of intents and intent stubs."""

import importlib
import json
import logging
import re
from typing import List, Set

import garak.data

is_loaded = False
intents = {}
cas_data_path = garak.data.path / "cas"


def start_msg() -> tuple[str, str]:
    """return a start message, assumes enabled"""
    return "ğŸ¯", "loading intent service"


def enabled() -> bool:
    """are requirements met for intent service to be enabled"""
    """we may want to predicate this on config"""
    return True


def _load_intent_typology(intents_path=None) -> None:
    global intents
    if intents_path is None:
        intents_path = cas_data_path / "trait_typology.json"
    with open(intents_path, "r", encoding="utf-8") as intents_file:
        intents = json.load(intents_file)


def load():
    """load the service"""
    global is_loaded
    _load_intent_typology()
    is_loaded = True


def _get_stubs_typology(intent_code: str) -> Set[str]:

    # return the descr of a given typology point, or if empty/absent, the name
    intent_details = intents.get(intent_code, {})

    stub = intent_details.get("descr")
    if not stub:
        stub = intent_details.get("name")

    stubs = (
        set(
            [
                stub,
            ]
        )
        if stub
        else set()
    )  # careful string doens't get char'd
    return stubs


def _get_stubs_file(intent_code: str) -> Set[str]:

    # search path: cas/intent_text/xxx_*.txt
    stub_dir = cas_data_path / "intent_stubs"
    stub_glob = stub_dir.glob(f"{intent_code}*.txt")

    stubs = set()
    for stub_file_path in stub_glob:
        if stub_file_path.exists():
            with open(stub_file_path, "r", encoding="utf-8") as sf:
                logging.info("intents: loading from %s" % stub_file_path)
                for line in sf:
                    stubs.add(line)

    return stubs


def _get_stubs_code(intent_code: str) -> Set[str]:
    # get intent stubs generated by an Intent class

    if len(intent_code) <= 4:  # code only supported for fully-specified intents
        return set()

    module_name = intent_code[:4]
    class_name = intent_code[4:].capitalize()

    try:
        intent_module = importlib.import_module(f"garak.intents.{module_name}")
        intent = getattr(intent_module, class_name)()
        stubs = intent.stubs()
    except ModuleNotFoundError:
        stubs = set()

    return stubs


def expand_intent_specifier_leaves(intent_specifier: str) -> List[str]:

    global intents

    intent_codes_to_lookup = [intent_specifier]

    # expand intent codes
    if len(intent_specifier) <= 4:
        for code in intents.keys():
            if code.startswith(intent_specifier) and len(code) > 4:
                intent_codes_to_lookup.append(code)

    return intent_codes_to_lookup


def get_intent_stubs(intent_specifier: str) -> Set[str]:
    """retrieve a list of intent strings given an intent code (doesn't have to be a leaf)"""

    global intents

    if not re.fullmatch("[CTMS]([0-9]{3}([a-z]+)?)?", intent_specifier):
        raise ValueError("Not a valid intent code: " + intent_specifier)

    if not intent_specifier in intents:
        raise ValueError("Intent code not in loaded typology: " + intent_specifier)

    intent_codes_to_lookup = expand_intent_specifier_leaves(intent_specifier)

    stubs = set()
    # retrieve intent stubs
    for candidate_code in intent_codes_to_lookup:
        stubs.update(_get_stubs_typology(candidate_code))
        stubs.update(_get_stubs_file(candidate_code))
        stubs.update(_get_stubs_code(candidate_code))

    # return stubs
    return stubs
